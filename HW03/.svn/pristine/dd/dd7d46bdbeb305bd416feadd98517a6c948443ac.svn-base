package model;

import model.balls.ABall;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.*;
import util.Dispatcher;
import javax.swing.Timer;
import util.Randomizer;
import model.strategy.*;

/**
 * Following is the class defining the current model being sued for BallWorld
 * 
 * @author wq3
 * @author ker7
 */
public class BallWorldModel {
	/**
	 * A _timeSlice set to allowed the animation to update every 50 milliseconds
	 */
	private int _timeSlice = 50;

	/**
	 * Observable of all the balls
	 * Allows easy control of balls (creation and removal)
	 */
	private Dispatcher myDispatcher = new Dispatcher();

	/**
	 * The model-to-view adapter object
	 * Set to NULL using the "Null Pattern"
	 */
	private IViewAdapter _model2ViewAdpt = IViewAdapter.NULL_OBJECT;

	/**
	 * Timer object to update the ball animation
	 */
	private Timer _timer = new Timer(_timeSlice, new ActionListener() {
		/**
		 * The timer "ticks" by calling this method every _timeslice milliseconds
		 * 
		 * @param e The event that represents what occurs on each timer tick
		 */
		public void actionPerformed(ActionEvent e) {
			_model2ViewAdpt.update();
		}
	});
	
	private SwitcherStrategy switcherStrategy;
	
	/**
	 * BallWorldModel constructor
	 * 
	 * @param model2ViewAdpt the interface that the model uses to talk to the view
	 */
	public BallWorldModel(IViewAdapter model2ViewAdpt) {
		_model2ViewAdpt = model2ViewAdpt;
	}

	/**
	 * called when view asked to paint the balls
	 * 
	 * @param g The object that will define how to paint the balls
	 */
	public void update(Graphics g) {
		myDispatcher.notifyAll(g);
	}

	/**
	 * Start the timer ticking
	 * Call initially from the controller.start() method to begin the model
	 */
	public void start() {
		_timer.start();
	}

	/**
	* The following method returns an instance of an ABall, given a fully qualified class name (package.classname) of
	* a subclass of ABall.
	* The method assumes that there is only one constructor for the supplied class that has the same *number* of
	* input parameters as specified in the args array and that it conforms to a specific
	* signature, i.e. specific order and types of input parameters in the args array.
	* 
	* @param className A string that is the fully qualified class name of the desired object
	* @return An instance of the supplied class. 
	*/
	private ABall loadBall(String className) {
		try {
			Point startLoc = Randomizer.singleton.randomLoc(_model2ViewAdpt.getCanvas().getSize());
			int startRadius = Randomizer.singleton.randomInt(10, 20);
			Point startVel = Randomizer.singleton.randomVel(new Rectangle(0, 0, 10, 25));
			Color startColor = Randomizer.singleton.randomColor();
			Component theCanvas = _model2ViewAdpt.getCanvas();
			Object[] args = new Object[] { startLoc, startRadius, startVel, startColor, theCanvas };
			java.lang.reflect.Constructor<?> cs[] = Class.forName(className).getConstructors(); // get all the constructors
			java.lang.reflect.Constructor<?> c = null;
			for (int i = 0; i < cs.length; i++) { // find the first constructor with the right number of input parameters
				if (args.length == (cs[i]).getParameterTypes().length) {
					c = cs[i];
					break;
				}
			}
			return (ABall) c.newInstance(args); // Call the constructor.   Will throw a null ptr exception if no constructor with the right number of input parameters was found.
		} catch (Exception ex) {
			System.err.println("Class " + className + " failed to load.");
			return null;
		}
	}

	/**
	 * Add a ball into the dispatcher observable with a given name(given class)
	 * 
	 * @param ball_name The class name of the ball that will be generated in the application
	 */
	public void dispatch_balls(String ball_name) {
		ABall single_ball = loadBall(ball_name);
		myDispatcher.addObserver(single_ball);
	}

	/**
	 * Wipe the canvas of all balls currently displaying
	 */
	public void clear_all_balls() {
		myDispatcher.deleteObservers();
	}
	
	public void clearBalls() {
		myDispatcher.deleteObservers();
	}
	
    public IStrategyFac makeStrategyFac(final String classname) {
    	IStrategyFac Strategy =  new IStrategyFac() {
            public IUpdateStrategy make() {
                return loadStrategy(fixName(classname));
            }

            public String toString() {
                return classname;
            }
        };
        return Strategy;
    }
    
	public IUpdateStrategy getSwitcherStrategy() {
		return switcherStrategy;
	}

	public void loadBall(IUpdateStrategy strategy){
		
	}
	
    public IStrategyFac combineStrategyFacs(final IStrategyFac stratFac1, final IStrategyFac stratFac2) {
    	IStrategyFac CombineStrategy = new IStrategyFac() {
            public IUpdateStrategy make() {
                return new MultiStrategy(stratFac1.make(), stratFac2.make());
            }

            public String toString() {
                return stratFac1.toString() + "-" + stratFac2.toString();
            }
        };
        return CombineStrategy;
    }
	
	public void switchSwitcherStrategy(IUpdateStrategy newStrategy){

	}
    
    private String fixName(String classname) {
    	String fixedName = "strategies." + classname + "Strategy";
		return fixedName;
	}
	
	/**
	 * This is the method that is called by the view's adapter to the model, i.e. is called by IView2ModelAdapter.paint().
	 * This method will update the sprites's painted locations by painting all the sprites
	 * onto the given Graphics object.
	 * @param g The Graphics object from the view's paintComponent() call.
	 */
	public void paint(Graphics g) {
		myDispatcher.notifyAll(g); // The Graphics object is being given to all the sprites (Observers)
	}

	/**
	 * add Observer to Dispatcher.
	 * @param ball ABall needs to be added as Observer.
	 */
	public void add(Ball ball) {
		myDispatcher.addObserver(ball);
	}
	
	/**
     * A factory for a beeping error strategy that beeps the speaker every 25 updates.
     * Either use the _errorStrategyFac variable directly if you need a factory that makes an error strategy,
     * or call _errorStrategyFac.make() to create an instance of a beeping error strategy.
     */
    private IStrategyFac _errorStrategyFac = new IStrategyFac(){
        @Override
        /**
         * Make the beeping error strategy
         * @return  An instance of a beeping error strategy
         */
        public IUpdateStrategy make() {
            return new IUpdateStrategy() {
                private int count = 0; // update counter
                @Override
                /**
                 * Beep the speaker every 25 updates
                 */
                public void updateState(Ball context) {
                    if(25 < count++){
                        java.awt.Toolkit.getDefaultToolkit().beep(); 
                        count = 0;
                    }
                }
            };
        }
    };
}
