package model.balls;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Point;
import java.util.Observable;
import java.util.Observer;

/**
 * Following is a class defining what a normal basic ball is
 * 
 * @author wq3
 * @author ker7
 */
public abstract class ABall implements Observer {

	/**
	 * A Ball's location on a x/y plane
	 **/
	protected Point location;

	/**
	 * A Ball's speed on an x/y plane
	 **/
	protected Point speed;

	/**
	 * A Ball's color represented as a "Color" object
	 **/
	protected Color color;

	/**
	 * The Ball's radius in pixels
	 **/
	protected int radius;

	/**
	 * The Ball's canvas 
	 * The location in the application where a ball is drawn
	 **/
	protected Component canvas;

	/**
	 * The method meant as the constructor for A Ball
	 * 
	 * @param startLoc location(x,y)
	 * @param startRadius radius
	 * @param startVel velocity(x,y)
	 * @param startColor ball's color
	 * @param theCanvas where to paint the ball
	 */
	public ABall(Point startLoc, int startRadius, Point startVel, Color startColor, Component theCanvas) {
		location = startLoc;
		radius = startRadius;
		speed = startVel;
		color = startColor;
		canvas = theCanvas;
	}

	/**
	 * variant methods for each different type of ball
	 */
	public abstract void variant();

	/**
	 * the basic movement of a ball in a straight way
	 */
	public void move() {
		//increase directional speed
		location.x += speed.x;
		location.y += speed.y;
	}

	/**
	 * bounce function to detect bouncing conditions between balls and the walls around them
	 */
	public void bounce() {
		//Check for wall collisions
		if (location.y - radius < 0) {
			speed.y = speed.y * -1;
			location.y = radius;
		}
		if (location.x - radius < 0) {
			speed.x = speed.x * -1;
			location.x = radius;
		}
		if (location.y + radius > canvas.getHeight()) {
			speed.y = speed.y * -1;
			location.y = canvas.getHeight() - radius;
		}
		if (location.x + radius > canvas.getWidth()) {
			speed.x = speed.x * -1;
			location.x = canvas.getWidth() - radius;
		}
	}

	/**
	 * Paint a sprite ball on the canvas
	 * 
	 * @param g Graphics object that will define how the balls will be painted
	 */
	public void draw(Graphics g) {
		//Update Paint
		g.setColor(color);

		//Draw shape
		g.fillOval(location.x - radius, location.y - radius, this.radius * 2, this.radius * 2);
	}

	/**
	 * Method to be called each time the balls currently on the canvas must be updated
	 * Moving, separating, and drawing separated to separate invariant and variant activities
	 * (All balls may bounce the same but not move the same)
	 * 
	 * @param o Observable hold dispatcher object
	 * @param g Graphics object onto which the sprite will paint itself
	 */
	public void update(Observable o, Object g) {
		variant();
		move();
		bounce();
		draw((Graphics) g);
	}

}
